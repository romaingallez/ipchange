package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"time"

	"github.com/pelletier/go-toml"
)

func init() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	log.SetPrefix("ipchange: ")
	log.SetOutput(os.Stderr)
}

// Generated by https://quicktype.io

type IPInfoResponse struct {
	IP       string `json:"ip"`
	City     string `json:"city"`
	Region   string `json:"region"`
	Country  string `json:"country"`
	LOC      string `json:"loc"`
	Org      string `json:"org"`
	Postal   string `json:"postal"`
	Timezone string `json:"timezone"`
}

// AppConfig holds our application data
type AppStorage struct {
	LastCheckTime time.Time
	LastIP        string
	LastNetwork   string
	LastSubnet    string
}

// Write a struct to store the api key and url
type AppConfig struct {
	Token string
	URL   string
}

func main() {
	// Initialize our application configuration
	var storage AppStorage
	var config AppConfig
	var ipChanged bool
	var networkChanged bool
	homeDir, _ := os.UserHomeDir()
	StorageFilePath := filepath.Join(homeDir, ".local", "ipchange", "storage.toml")
	ConfigFilePath := filepath.Join(homeDir, ".local", "ipchange", "config.toml")

	storagePath, _ := filepath.Abs(os.ExpandEnv(StorageFilePath))
	if _, err := os.Stat(storagePath); err == nil {
		storage = loadStorage(storagePath)
	} else if os.IsNotExist(err) {
		err := os.MkdirAll(filepath.Dir(storagePath), 0755)
		if err != nil {
			log.Println(err)
		}
		storage = AppStorage{}
	}

	configPath, _ := filepath.Abs(os.ExpandEnv(ConfigFilePath))
	if _, err := os.Stat(configPath); err == nil {
		config = loadConfig(configPath)
	} else if os.IsNotExist(err) {
		err := os.MkdirAll(filepath.Dir(configPath), 0755)
		if err != nil {
			log.Println(err)
		}
		config = AppConfig{}
		saveConfig(configPath, config)
	}

	// if it was less than 5 minutes since the last check, return the last IP without calling ipinfo.io
	interfaces, _ := net.Interfaces()
	for _, i := range interfaces {
		addrs, _ := i.Addrs()
		for _, addr := range addrs {
			var ip net.IP
			switch v := addr.(type) {
			case *net.IPNet:
				ip = v.IP
			case *net.IPAddr:
				ip = v.IP
			}
			if ip.IsGlobalUnicast() {
				if i.Name != storage.LastNetwork || addr.String() != storage.LastSubnet {
					storage.LastNetwork = i.Name
					storage.LastSubnet = addr.String()
					networkChanged = true
				}
				break
			}
		}
	}

	if networkChanged {

		ip, err := getPublicIP(config)
		if err != nil {
			log.Fatal(err)
		}
		ipChanged = ip != storage.LastIP
		storage.LastIP = ip
		storage.LastCheckTime = time.Now()
		saveStorage(storagePath, storage)
	}

	result := map[string]interface{}{
		"last_time_check": storage.LastCheckTime.Format(time.RFC3339),
		"public_op":       storage.LastIP,
		"ip_changed":      ipChanged,
	}

	jsonResult, _ := json.Marshal(result)
	fmt.Println(string(jsonResult))
}

func getPublicIP(info AppConfig) (string, error) {
	client := &http.Client{}
	req, err := http.NewRequest("GET", info.URL, nil)
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+info.Token)

	res, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer res.Body.Close()

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return "", err
	}

	var ipinfo IPInfoResponse
	err = json.Unmarshal(body, &ipinfo)
	if err != nil {
		return "", err
	}

	return ipinfo.IP, nil
}

func loadStorage(path string) AppStorage {
	file, _ := os.ReadFile(path)
	var storage AppStorage
	_ = toml.Unmarshal(file, &storage)
	return storage
}

func saveStorage(path string, storage AppStorage) {
	file, _ := toml.Marshal(&storage)
	_ = os.WriteFile(path, file, 0644)
}

func loadConfig(path string) AppConfig {
	file, _ := os.ReadFile(path)
	var config AppConfig
	_ = toml.Unmarshal(file, &config)
	return config
}

func saveConfig(path string, config AppConfig) {
	file, _ := toml.Marshal(&config)
	_ = os.WriteFile(path, file, 0644)
}
