package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"time"

	"github.com/pelletier/go-toml"
)

func init() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	log.SetPrefix("ipchange: ")
	log.SetOutput(os.Stderr)
}

type IPRoute struct {
	Dst     string   `json:"dst"`
	Gateway string   `json:"gateway"`
	Dev     string   `json:"dev"`
	PrefSrc string   `json:"prefsrc"`
	Flags   []string `json:"flags"`
	UID     int      `json:"uid"`
	Cache   []string `json:"cache"`
}

// Generated by https://quicktype.io

type IPInfoResponse struct {
	IP       string `json:"ip"`
	City     string `json:"city"`
	Region   string `json:"region"`
	Country  string `json:"country"`
	LOC      string `json:"loc"`
	Org      string `json:"org"`
	Postal   string `json:"postal"`
	Timezone string `json:"timezone"`
}

// AppConfig holds our application data
type AppStorage struct {
	LastCheckTime time.Time
	LastIP        string
	LastNetwork   string
	LastSubnet    string
	IPChanged     bool
}

// Write a struct to store the api key and url
type AppConfig struct {
	Token string
	URL   string
}

func main() {
	// Initialize our application configuration
	var storage AppStorage
	var config AppConfig
	var ipChanged bool
	var networkChanged bool
	homeDir, _ := os.UserHomeDir()
	StorageFilePath := filepath.Join(homeDir, ".local", "ipchange", "storage.toml")
	ConfigFilePath := filepath.Join(homeDir, ".local", "ipchange", "config.toml")
	LogFilePath := filepath.Join(homeDir, ".local", "ipchange", "ipchange.log")

	storagePath, _ := filepath.Abs(os.ExpandEnv(StorageFilePath))
	if _, err := os.Stat(storagePath); err == nil {
		storage = loadStorage(storagePath)
	} else if os.IsNotExist(err) {
		err := os.MkdirAll(filepath.Dir(storagePath), 0755)
		if err != nil {
			log.Println(err)
		}
		storage = AppStorage{}
	}

	configPath, _ := filepath.Abs(os.ExpandEnv(ConfigFilePath))
	if _, err := os.Stat(configPath); err == nil {
		config = loadConfig(configPath)
	} else if os.IsNotExist(err) {
		err := os.MkdirAll(filepath.Dir(configPath), 0755)
		if err != nil {
			log.Println(err)
		}
		config = AppConfig{}
		saveConfig(configPath, config)
	}

	switch runtime.GOOS {
	case "linux":

		cmd := exec.Command("ip", "--json", "route", "get", "1")
		output, err := cmd.Output()
		if err != nil {
			log.Fatalf("Error executing ip command: %v", err)
		}

		var routes []IPRoute
		if err := json.Unmarshal(output, &routes); err != nil {
			log.Fatalf("Error parsing JSON output: %v", err)
		}

		if len(routes) > 0 {
			route := routes[0]
			if route.Dev != storage.LastNetwork || route.PrefSrc != storage.LastSubnet {
				storage.LastNetwork = route.Dev
				storage.LastSubnet = route.PrefSrc
			}
		}

	default:
		log.Printf("OS %s is not supported", runtime.GOOS)
	}

	// if it was less than 5 minutes since the last check, return the last IP without calling ipinfo.io
	// interfaces, _ := net.Interfaces()
	// for _, i := range interfaces {
	// 	addrs, _ := i.Addrs()
	// 	for _, addr := range addrs {
	// 		var ip net.IP
	// 		switch v := addr.(type) {
	// 		case *net.IPNet:
	// 			ip = v.IP
	// 		case *net.IPAddr:
	// 			ip = v.IP
	// 		}
	// 		if ip.IsGlobalUnicast() {
	// 			if i.Name != storage.LastNetwork || addr.String() != storage.LastSubnet {
	// 				storage.LastNetwork = i.Name
	// 				storage.LastSubnet = addr.String()
	// 				networkChanged = true
	// 			}
	// 			break
	// 		}
	// 	}
	// }

	if networkChanged {

		ip, err := getPublicIP(config)
		if err != nil {
			log.Fatal(err)
		}
		ipChanged = ip != storage.LastIP
		storage.LastIP = ip
		storage.LastCheckTime = time.Now()
		saveStorage(storagePath, storage)
	}

	// result := map[string]interface{}{
	// 	"last_time_check": storage.LastCheckTime.Format(time.RFC3339),
	// 	"public_op":       storage.LastIP,
	// 	"ip_changed":      ipChanged,
	// }
	storage.IPChanged = ipChanged

	jsonResult, _ := json.Marshal(storage)
	fmt.Println(string(jsonResult))
	saveLog(LogFilePath, jsonResult)
}

func getPublicIP(info AppConfig) (string, error) {
	client := &http.Client{}
	req, err := http.NewRequest("GET", info.URL, nil)
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+info.Token)

	res, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer res.Body.Close()

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return "", err
	}

	var ipinfo IPInfoResponse
	err = json.Unmarshal(body, &ipinfo)
	if err != nil {
		return "", err
	}

	return ipinfo.IP, nil
}

func loadStorage(path string) AppStorage {
	file, _ := os.ReadFile(path)
	var storage AppStorage
	_ = toml.Unmarshal(file, &storage)
	return storage
}

// saveLog appends the log to the log file
// if the file does not exist, create it with 0644 permissions
func saveLog(path string, logData []byte) {
	file, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Println(err)
		return
	}
	defer file.Close()

	// Append a newline to the log data
	logData = append(logData, '\n')

	if _, err := file.Write(logData); err != nil {
		log.Println(err)
	}
}

func saveStorage(path string, storage AppStorage) {
	file, _ := toml.Marshal(&storage)
	_ = os.WriteFile(path, file, 0644)
}

func loadConfig(path string) AppConfig {
	file, _ := os.ReadFile(path)
	var config AppConfig
	_ = toml.Unmarshal(file, &config)
	return config
}

func saveConfig(path string, config AppConfig) {
	file, _ := toml.Marshal(&config)
	_ = os.WriteFile(path, file, 0644)
}
